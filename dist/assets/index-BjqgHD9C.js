(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const h of r.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&s(h)}).observe(document,{childList:!0,subtree:!0});function e(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(n){if(n.ep)return;n.ep=!0;const r=e(n);fetch(n.href,r)}})();const i={CANVAS_WIDTH:1200,CANVAS_HEIGHT:1200,INTERSECTION_SIZE:120,ROAD_WIDTH:60,LANE_WIDTH:30,CAR_WIDTH:16,CAR_HEIGHT:8,CAR_COLORS:["#FF0000","#00FF00","#0000FF","#FFFF00","#FFA500","#FFFFFF","#000000","#888888"],DIRECTIONS:{NORTH:"north",SOUTH:"south",EAST:"east",WEST:"west"},TURN_TYPES:{STRAIGHT:"straight",LEFT:"left",RIGHT:"right"},MODES:{FIXED:"fixed",ADAPTIVE:"adaptive"},LIGHT_SIZE:12,LIGHT_STATES:{RED:"red",YELLOW:"yellow",GREEN:"green"},DEFAULT_SETTINGS:{GREEN_DURATION:1e5,YELLOW_DURATION:5e3,RED_DURATION:1e5,ALL_RED_DURATION:2e3,CAR_SPAWN_RATE:4,CAR_SPEED:25,TURN_RATE:.25,DETECTOR_DISTANCE:200,MIN_GREEN_TIME:5e3},ADAPTIVE_SETTINGS:{DETECTOR_DISTANCE_RANGE:[100,500]}};class m{constructor(t,e){this.centerX=t,this.centerY=e,this.size=i.INTERSECTION_SIZE,this.roadWidth=i.ROAD_WIDTH,this.laneWidth=i.LANE_WIDTH,this.calculatePositions()}initialize(){this.calculatePositions()}calculatePositions(){const t=this.size/2,e=this.roadWidth/2,s=this.laneWidth/2,n=t+5;this.stopLines={[i.DIRECTIONS.NORTH]:{x1:this.centerX-e,y1:this.centerY-n,x2:this.centerX+e,y2:this.centerY-n},[i.DIRECTIONS.EAST]:{x1:this.centerX+n,y1:this.centerY-e,x2:this.centerX+n,y2:this.centerY+e},[i.DIRECTIONS.SOUTH]:{x1:this.centerX-e,y1:this.centerY+n,x2:this.centerX+e,y2:this.centerY+n},[i.DIRECTIONS.WEST]:{x1:this.centerX-n,y1:this.centerY-e,x2:this.centerX-n,y2:this.centerY+e}},this.lightPositions={[i.DIRECTIONS.NORTH]:{x:this.centerX-25,y:this.centerY-t-40},[i.DIRECTIONS.EAST]:{x:this.centerX+t+15,y:this.centerY-25},[i.DIRECTIONS.SOUTH]:{x:this.centerX+25,y:this.centerY+t+15},[i.DIRECTIONS.WEST]:{x:this.centerX-t-40,y:this.centerY+25}},this.spawnPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX-s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY-s},[i.DIRECTIONS.SOUTH]:{x:this.centerX+s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY+s}},this.exitPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX+s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY+s},[i.DIRECTIONS.SOUTH]:{x:this.centerX-s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY-s}}}render(t){this.drawRoads(t),this.drawIntersection(t),this.drawLaneMarkings(t),this.drawStopLines(t)}drawRoads(t){const e=this.roadWidth/2;t.fillStyle="#444444",t.fillRect(this.centerX-e,0,this.roadWidth,i.CANVAS_HEIGHT),t.fillRect(0,this.centerY-e,i.CANVAS_WIDTH,this.roadWidth)}drawIntersection(t){const e=this.roadWidth/2,s=e;t.fillStyle="#666666",t.beginPath(),t.moveTo(this.centerX-e,this.centerY-e-s),t.quadraticCurveTo(this.centerX-e,this.centerY-e,this.centerX-e-s,this.centerY-e),t.lineTo(this.centerX-e-s,this.centerY+e),t.quadraticCurveTo(this.centerX-e,this.centerY+e,this.centerX-e,this.centerY+e+s),t.lineTo(this.centerX+e,this.centerY+e+s),t.quadraticCurveTo(this.centerX+e,this.centerY+e,this.centerX+e+s,this.centerY+e),t.lineTo(this.centerX+e+s,this.centerY-e),t.quadraticCurveTo(this.centerX+e,this.centerY-e,this.centerX+e,this.centerY-e-s),t.closePath(),t.fill(),t.globalCompositeOperation="source-over"}drawLaneMarkings(t){t.strokeStyle="#ffffff",t.lineWidth=2,t.setLineDash([10,10]);const e=this.roadWidth/2;t.beginPath(),t.moveTo(this.centerX,0),t.lineTo(this.centerX,this.centerY-e),t.moveTo(this.centerX,this.centerY+e),t.lineTo(this.centerX,i.CANVAS_HEIGHT),t.stroke(),t.beginPath(),t.moveTo(0,this.centerY),t.lineTo(this.centerX-e,this.centerY),t.moveTo(this.centerX+e,this.centerY),t.lineTo(i.CANVAS_WIDTH,this.centerY),t.stroke(),t.setLineDash([])}drawStopLines(t){t.strokeStyle="#ffffff",t.lineWidth=4,Object.values(this.stopLines).forEach(e=>{t.beginPath(),t.moveTo(e.x1,e.y1),t.lineTo(e.x2,e.y2),t.stroke()})}getStopLinePosition(t){return this.stopLines[t]}getSpawnPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getExitPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getLightPosition(t){if(!t||typeof t!="string"){console.warn("Invalid direction for getLightPosition:",t);return}return this.lightPositions[t]}isInIntersection(t,e){const s=this.roadWidth/2;return t>=this.centerX-s&&t<=this.centerX+s&&e>=this.centerY-s&&e<=this.centerY+s}getProperExitPoint(t,e,s){const n=this.laneWidth/2;if(s===i.TURN_TYPES.RIGHT)switch(t){case i.DIRECTIONS.NORTH:case i.DIRECTIONS.SOUTH:return{x:i.CANVAS_WIDTH,y:this.centerY-n};case i.DIRECTIONS.WEST:return{x:this.centerX-n,y:i.CANVAS_HEIGHT};case i.DIRECTIONS.EAST:return{x:this.centerX+n,y:0}}else if(s===i.TURN_TYPES.LEFT)switch(t){case i.DIRECTIONS.NORTH:case i.DIRECTIONS.SOUTH:return{x:0,y:this.centerY+n};case i.DIRECTIONS.WEST:return{x:this.centerX+n,y:0};case i.DIRECTIONS.EAST:return{x:this.centerX-n,y:i.CANVAS_HEIGHT}}else return this.exitPoints[e]}getTurningPath(t,e,s){return[this.getPathEntryPoint(t),this.getProperExitPoint(t,e,s)]}getPathEntryPoint(t){const e=this.roadWidth/2,s=this.laneWidth/2;switch(t){case i.DIRECTIONS.NORTH:return{x:this.centerX-s,y:this.centerY-e};case i.DIRECTIONS.EAST:return{x:this.centerX+e,y:this.centerY-s};case i.DIRECTIONS.SOUTH:return{x:this.centerX+s,y:this.centerY+e};case i.DIRECTIONS.WEST:return{x:this.centerX-e,y:this.centerY+s}}}setCarManager(t){this.carManager=t}getAllCars(){return this.carManager?this.carManager.getCars():[]}}const E=new m(400,300);typeof E.getExitpoint=="function"&&direction?E.getExitpoint(direction):console.warn("getExitpoint is not a function or direction is undefined");class D{constructor(){this.lights={},this.mode=i.MODES.FIXED,this.currentPhase=0,this.phaseTimer=0,this.adaptiveData={},this.lastGreenChange=0,this.initializeLights()}initializeLights(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t]={state:i.LIGHT_STATES.RED,timer:0}})}initialize(t,e){this.mode=t,this.settings=e,this.reset()}reset(){this.currentPhase=0,this.phaseTimer=0,this.lastGreenChange=0,this.mode===i.MODES.FIXED?this.setFixedTimerState():this.setAdaptiveState()}update(t,e,s){this.mode=e,this.settings=s,this.mode===i.MODES.FIXED?this.updateFixedTimer(t):this.updateAdaptive(t)}updateFixedTimer(t){switch(this.phaseTimer+=t,this.currentPhase){case 0:this.phaseTimer>=this.settings.GREEN_DURATION&&this.advancePhase();break;case 1:this.phaseTimer>=this.settings.YELLOW_DURATION&&this.advancePhase();break;case 2:this.phaseTimer>=this.settings.ALL_RED_DURATION&&this.advancePhase();break;case 3:this.phaseTimer>=this.settings.GREEN_DURATION&&this.advancePhase();break;case 4:this.phaseTimer>=this.settings.YELLOW_DURATION&&this.advancePhase();break;case 5:this.phaseTimer>=this.settings.ALL_RED_DURATION&&this.advancePhase();break}}updateAdaptive(t){if(this.phaseTimer+=t,!(this.phaseTimer<this.settings.MIN_GREEN_TIME)&&this.adaptiveData&&Object.keys(this.adaptiveData).length>0){const e=this.getCurrentGreenDirection(),s=this.calculateNextDirection();s!==e&&s!==null&&this.changeToDirection(s)}}updateAdaptiveLogic(t,e){this.adaptiveData=t}advancePhase(){this.currentPhase=(this.currentPhase+1)%6,this.phaseTimer=0,this.setFixedTimerState()}setFixedTimerState(){switch(Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t].state=i.LIGHT_STATES.RED}),this.currentPhase){case 0:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.GREEN;break;case 1:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.YELLOW;break;case 2:break;case 3:this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.GREEN;break;case 4:this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.YELLOW;break}}setAdaptiveState(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t].state=i.LIGHT_STATES.RED}),this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.GREEN}getCurrentGreenDirection(){for(const[t,e]of Object.entries(this.lights))if(e.state===i.LIGHT_STATES.GREEN)return t;return null}calculateNextDirection(){if(!this.adaptiveData)return null;let t=0,e=null;return Object.entries(this.adaptiveData).forEach(([s,n])=>{if(this.lights[s].state!==i.LIGHT_STATES.GREEN&&n.carsWaiting>0){const r=n.carsWaiting*(n.waitTime/1e3);r>t&&(t=r,e=s)}}),e}changeToDirection(t){Object.values(i.DIRECTIONS).forEach(e=>{this.lights[e].state=i.LIGHT_STATES.RED}),t===i.DIRECTIONS.NORTH||t===i.DIRECTIONS.SOUTH?(this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.GREEN):(this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.GREEN),this.phaseTimer=0,this.lastGreenChange=Date.now()}render(t,e){["north","south","east","west"].forEach(n=>{const r=this.lights[i.DIRECTIONS[n.toUpperCase()]].state;this.renderTrafficLight(t,n,r,e)})}renderTrafficLight(t,e,s,n){const r=n.getLightPosition(e);if(!r)return;const h=i.LIGHT_SIZE,o=h+2;t.fillStyle="#333",t.fillRect(r.x-h-1,r.y-o*1.5-1,(h+1)*2,o*3+2),["red","yellow","green"].forEach((l,d)=>{const T=r.y-o+d*o;t.fillStyle="#222",t.beginPath(),t.arc(r.x,T,h,0,Math.PI*2),t.fill(),s===l&&(t.fillStyle=l,t.beginPath(),t.arc(r.x,T,h-2,0,Math.PI*2),t.fill())})}getLightStates(){const t={};return Object.entries(this.lights).forEach(([e,s])=>{t[e]=s.state}),t}setMode(t){this.mode=t,this.reset()}updateSettings(t){this.settings=t}isRedLight(t){return this.lights[t].state===i.LIGHT_STATES.RED}canProceed(t){const e=this.lights[t].state;return e===i.LIGHT_STATES.GREEN||e===i.LIGHT_STATES.YELLOW}}const R={getDistance(a,t,e,s){const n=e-a,r=s-t;return Math.sqrt(n*n+r*r)},getAngle(a,t,e,s){return Math.atan2(s-t,e-a)},getAngleDifference(a,t){let e=t-a;for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e},normalizeAngle(a){for(;a>Math.PI;)a-=2*Math.PI;for(;a<-Math.PI;)a+=2*Math.PI;return a},lerp(a,t,e){return a+(t-a)*e},clamp(a,t,e){return Math.min(Math.max(a,t),e)},randomBetween(a,t){return Math.random()*(t-a)+a},randomInt(a,t){return Math.floor(Math.random()*(t-a+1))+a},randomFromArray(a){return a[Math.floor(Math.random()*a.length)]},formatTime(a){return(a/1e3).toFixed(1)},hexToRgba(a,t=1){const e=parseInt(a.slice(1,3),16),s=parseInt(a.slice(3,5),16),n=parseInt(a.slice(5,7),16);return`rgba(${e}, ${s}, ${n}, ${t})`},isPointInRect(a,t,e,s,n,r){return a>=e&&a<=e+n&&t>=s&&t<=s+r},smoothStep(a,t,e){const s=this.clamp((e-a)/(t-a),0,1);return s*s*(3-2*s)},getBezierPoint(a,t,e,s,n){const r=3*(e.x-t.x),h=3*(s.x-e.x)-r,o=n.x-t.x-r-h,c=3*(e.y-t.y),l=3*(s.y-e.y)-c,d=n.y-t.y-c-l,T=a*a,u=T*a;return{x:o*u+h*T+r*a+t.x,y:d*u+l*T+c*a+t.y}}};class C{constructor({id:t,direction:e,intersection:s}){this.id=t,this.fromDirection=e,this.intersection=s;const n=Math.random();n<.33?this.turnType=i.TURN_TYPES.LEFT:n<.66?this.turnType=i.TURN_TYPES.RIGHT:this.turnType=i.TURN_TYPES.STRAIGHT,this.toDirection=this.calculateToDirection();const r=s.spawnPoints[e];this.x=r.x,this.y=r.y,this.angle=this.getInitialAngle(),this.speed=0,this.maxSpeed=i.DEFAULT_SETTINGS.CAR_SPEED,this.width=i.CAR_WIDTH,this.height=i.CAR_HEIGHT,this.color=i.CAR_COLORS[Math.floor(Math.random()*i.CAR_COLORS.length)],this.state="approaching",this.waitStartTime=null,this.totalWaitTime=0,this.isInIntersection=!1,this.pathProgress=0,this.turningPath=null,this.hasStartedTurn=!1,this.turnProgress=0,this.calculateTargetPosition()}calculateToDirection(){const t=[i.DIRECTIONS.NORTH,i.DIRECTIONS.EAST,i.DIRECTIONS.SOUTH,i.DIRECTIONS.WEST],e=t.indexOf(this.fromDirection);switch(this.turnType){case i.TURN_TYPES.LEFT:return t[(e+3)%4];case i.TURN_TYPES.RIGHT:return t[(e+1)%4];case i.TURN_TYPES.STRAIGHT:default:return t[(e+2)%4]}}getInitialAngle(){switch(this.fromDirection){case i.DIRECTIONS.NORTH:return Math.PI/2;case i.DIRECTIONS.EAST:return Math.PI;case i.DIRECTIONS.SOUTH:return-Math.PI/2;case i.DIRECTIONS.WEST:return 0;default:return 0}}calculateTargetPosition(){if(this.intersection&&typeof this.intersection.getExitPoint=="function"&&this.direction){const t=this.intersection.getExitPoint(this.direction);if(!t||typeof t.x!="number"||typeof t.y!="number"){console.warn("Target position is undefined or invalid for car",this.id);return}this.targetX=t.x,this.targetY=t.y}else console.warn("intersection.getExitPoint is not a function or direction is missing")}update(t,e){const s=t/1e3;switch(this.state){case"approaching":this.updateApproaching(s,e);break;case"waiting":this.updateWaiting(s,e);break;case"crossing":this.updateCrossing(s);break;case"exiting":this.updateExiting(s);break}this.speed>0&&(this.x+=Math.cos(this.angle)*this.speed*s,this.y+=Math.sin(this.angle)*this.speed*s),this.isInIntersection=this.intersection.isInIntersection(this.x,this.y)}updateApproaching(t,e){const s=this.intersection.getStopLinePosition(this.fromDirection),n=this.getDistanceToStopLine(s),r=this.checkForCarAhead(),h=r&&this.getDistanceToCarAhead(r)<35;if((n<=30||h)&&(e[this.fromDirection]===i.LIGHT_STATES.RED||h)){this.state="waiting",this.speed=0,h||(this.waitStartTime=Date.now());return}this.speed=Math.min(this.maxSpeed,this.speed+30*t),this.isInIntersection&&(this.state="crossing")}updateWaiting(t,e){this.speed=0,this.waitStartTime&&(this.totalWaitTime=Date.now()-this.waitStartTime),(e[this.fromDirection]===i.LIGHT_STATES.GREEN||e[this.fromDirection]===i.LIGHT_STATES.YELLOW)&&(this.state="crossing",this.waitStartTime=null)}updateCrossing(t){this.speed=Math.min(this.maxSpeed*1.2,this.speed+40*t),this.isInIntersection&&!this.hasStartedTurn&&(this.hasStartedTurn=!0,this.turnProgress=0),this.hasStartedTurn&&this.turnProgress<1&&this.performTurn(t),!this.isInIntersection&&this.pathProgress>0&&(this.state="exiting"),this.pathProgress+=t}getTargetExitAngle(){switch(this.toDirection){case i.DIRECTIONS.NORTH:return-Math.PI/2;case i.DIRECTIONS.EAST:return 0;case i.DIRECTIONS.SOUTH:return Math.PI/2;case i.DIRECTIONS.WEST:return Math.PI;default:return this.angle}}updateExiting(t){this.speed=this.maxSpeed;let e=!1;e=this.x<-50||this.x>i.CANVAS_WIDTH+50||this.y<-50||this.y>i.CANVAS_HEIGHT+50,e&&(this.state="completed")}getDistanceToStopLine(t){switch(this.fromDirection){case i.DIRECTIONS.NORTH:return Math.abs(this.y-t.y1);case i.DIRECTIONS.EAST:return Math.abs(this.x-t.x1);case i.DIRECTIONS.SOUTH:return Math.abs(this.y-t.y1);case i.DIRECTIONS.WEST:return Math.abs(this.x-t.x1);default:return 0}}render(t){if(t.save(),t.translate(this.x,this.y),t.rotate(this.angle),t.fillStyle=this.color,t.fillRect(-this.width/2,-this.height/2,this.width,this.height),t.fillStyle="#333333",t.fillRect(-this.width/2+2,-this.height/2+2,this.width-4,3),t.fillRect(-this.width/2+2,this.height/2-5,this.width-4,3),this.state==="waiting"||this.state==="approaching"){t.fillStyle="rgba(255, 255, 255, 0.8)";const e=this.turnType===i.TURN_TYPES.LEFT?"←":this.turnType===i.TURN_TYPES.RIGHT?"→":"↑";t.font="12px Arial",t.textAlign="center",t.fillText(e,0,-this.height/2-10)}t.restore()}isWaiting(){return this.state==="waiting"}isCompleted(){return this.state==="completed"}getWaitTime(){return this.totalWaitTime}getDirection(){return this.fromDirection}checkForCarAhead(){const t=this.intersection.carManager?this.intersection.carManager.getCars():[];let e=null,s=1/0;for(const n of t){if(n.id===this.id||n.fromDirection!==this.fromDirection)continue;let r=!1,h=0;switch(this.fromDirection){case i.DIRECTIONS.NORTH:r=n.y>this.y,h=n.y-this.y;break;case i.DIRECTIONS.EAST:r=n.x<this.x,h=this.x-n.x;break;case i.DIRECTIONS.SOUTH:r=n.y<this.y,h=this.y-n.y;break;case i.DIRECTIONS.WEST:r=n.x>this.x,h=n.x-this.x;break}r&&h>0&&h<s&&(s=h,e=n)}return e}getDistanceToCarAhead(t){if(!t)return 1/0;switch(this.fromDirection){case i.DIRECTIONS.NORTH:return t.y-this.y;case i.DIRECTIONS.EAST:return this.x-t.x;case i.DIRECTIONS.SOUTH:return this.y-t.y;case i.DIRECTIONS.WEST:return t.x-this.x;default:return 1/0}}moveToTargetPosition(){}performTurn(t){if(this.turnProgress+=t*2,this.turnType===i.TURN_TYPES.STRAIGHT)return;let e=this.angle;this.turnType===i.TURN_TYPES.RIGHT?e=this.angle+Math.PI/2:this.turnType===i.TURN_TYPES.LEFT&&(e=this.angle-Math.PI/2);const s=e-this.angle;for(this.angle+=s*Math.min(this.turnProgress,1)*t*3;this.angle>Math.PI;)this.angle-=2*Math.PI;for(;this.angle<-Math.PI;)this.angle+=2*Math.PI;this.turnProgress>=1&&(this.angle=e,this.moveToProperLane())}moveToProperLane(){const t=i.LANE_WIDTH/2,e=this.intersection.centerX,s=this.intersection.centerY;switch(this.toDirection){case i.DIRECTIONS.NORTH:this.x=e+t;break;case i.DIRECTIONS.SOUTH:this.x=e-t;break;case i.DIRECTIONS.EAST:this.y=s-t;break;case i.DIRECTIONS.WEST:this.y=s+t;break}}}class p{constructor(t){this.intersection=t,this.cars=[],this.nextCarId=1,this.spawnTimer=0,this.settings={...i.DEFAULT_SETTINGS},this.onCarCompleted=null,this.intersection.carManager=this}initialize(t){this.settings={...t},this.cars=[],this.nextCarId=1,this.spawnTimer=0}update(t,e){this.spawnTimer+=t;const s=1e4/this.settings.CAR_SPAWN_RATE;this.spawnTimer>=s&&(this.spawnCar(),this.spawnTimer=0),this.cars.forEach(r=>{r.maxSpeed=this.settings.CAR_SPEED,r.update(t,e)}),this.cars.filter(r=>r.isCompleted()).forEach(r=>{this.onCarCompleted&&this.onCarCompleted(r)}),this.cars=this.cars.filter(r=>!r.isCompleted())}spawnCar(){const t=[i.DIRECTIONS.NORTH,i.DIRECTIONS.EAST,i.DIRECTIONS.SOUTH,i.DIRECTIONS.WEST],e=t[Math.floor(Math.random()*t.length)],s=this.intersection.spawnPoints[e];if(!this.cars.some(r=>{const h=R.getDistance(r.x,r.y,s.x,s.y);return r.fromDirection===e&&h<60})){const r=new C({id:this.nextCarId++,direction:e,intersection:this.intersection});this.cars.push(r)}}render(t){this.cars.forEach(e=>e.render(t))}reset(){this.cars=[],this.nextCarId=1,this.spawnTimer=0}updateSettings(t){this.settings={...t}}getCars(){return[...this.cars]}getWaitingCars(t){return this.cars.filter(e=>e.getDirection()===t&&e.isWaiting())}getCurrentCarCount(){return this.cars.length}}class N{constructor(t){this.intersection=t,this.detectorDistance=i.DEFAULT_SETTINGS.DETECTOR_DISTANCE,this.sensorData={},this.initializeSensors()}initializeSensors(){Object.values(i.DIRECTIONS).forEach(t=>{this.sensorData[t]={carsWaiting:0,waitTime:0,detectedCars:[],firstCarWaitStart:null}})}initialize(t){this.detectorDistance=t,this.initializeSensors()}update(t){return Object.values(i.DIRECTIONS).forEach(e=>{this.sensorData[e]={carsWaiting:0,waitTime:0,detectedCars:[],firstCarWaitStart:null}}),t.forEach(e=>{const s=e.getDirection(),n=this.getDetectionZone(s);this.isCarInDetectionZone(e,n)&&(this.sensorData[s].detectedCars.push(e),e.isWaiting()&&(this.sensorData[s].carsWaiting++,this.sensorData[s].firstCarWaitStart||(this.sensorData[s].firstCarWaitStart=Date.now()-e.getWaitTime())))}),Object.values(i.DIRECTIONS).forEach(e=>{this.sensorData[e].carsWaiting>0&&this.sensorData[e].firstCarWaitStart&&(this.sensorData[e].waitTime=Date.now()-this.sensorData[e].firstCarWaitStart)}),this.sensorData}getDetectionZone(t){const e=this.intersection.getStopLinePosition(t),s=i.ROAD_WIDTH;switch(t){case i.DIRECTIONS.NORTH:return{x1:this.intersection.centerX-s/2,y1:e.y1-this.detectorDistance,x2:this.intersection.centerX+s/2,y2:e.y1};case i.DIRECTIONS.EAST:return{x1:e.x1,y1:this.intersection.centerY-s/2,x2:e.x1+this.detectorDistance,y2:this.intersection.centerY+s/2};case i.DIRECTIONS.SOUTH:return{x1:this.intersection.centerX-s/2,y1:e.y1,x2:this.intersection.centerX+s/2,y2:e.y1+this.detectorDistance};case i.DIRECTIONS.WEST:return{x1:e.x1-this.detectorDistance,y1:this.intersection.centerY-s/2,x2:e.x1,y2:this.intersection.centerY+s/2};default:return{x1:0,y1:0,x2:0,y2:0}}}isCarInDetectionZone(t,e){return t.x>=e.x1&&t.x<=e.x2&&t.y>=e.y1&&t.y<=e.y2}render(t){t.strokeStyle="rgba(255, 165, 0, 0.8)",t.fillStyle="rgba(255, 165, 0, 0.1)",t.lineWidth=2,t.setLineDash([5,5]),Object.values(i.DIRECTIONS).forEach(e=>{const s=this.getDetectionZone(e);t.fillRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1),t.strokeRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1);const n=(s.x1+s.x2)/2,r=(s.y1+s.y2)/2,h=this.sensorData[e];h.carsWaiting>0&&(t.fillStyle="rgba(255, 255, 255, 0.9)",t.fillRect(n-25,r-10,50,20),t.fillStyle="#333333",t.font="12px Arial",t.textAlign="center",t.fillText(`${h.carsWaiting}`,n,r+4))}),t.setLineDash([])}updateDetectorDistance(t){this.detectorDistance=t}getSensorData(){return{...this.sensorData}}}class y{constructor(){this.reset()}initialize(){this.reset()}reset(){this.totalCarsPassed=0,this.totalWaitTime=0,this.currentCars=0,this.waitTimes=[]}update(t,e){this.currentCars=t.length}recordCarCompletion(t){this.totalCarsPassed++;const e=t.getWaitTime();e>0&&(this.totalWaitTime+=e,this.waitTimes.push(e))}getStats(){const t=this.waitTimes.length>0?this.waitTimes.reduce((e,s)=>e+s,0)/this.waitTimes.length:0;return{totalCarsPassed:this.totalCarsPassed,averageWaitTime:t/1e3,currentCars:this.currentCars}}}class O{constructor(t,e){this.canvas=t,this.ctx=e,this.intersection=new m(i.CANVAS_WIDTH/2,i.CANVAS_HEIGHT/2),this.trafficLights=new D,this.carManager=new p(this.intersection),this.sensorSystem=new N(this.intersection),this.statistics=new y,this.mode=i.MODES.FIXED,this.settings={...i.DEFAULT_SETTINGS},this.setupEventListeners()}initialize(){this.intersection.initialize(),this.intersection.setCarManager(this.carManager),this.trafficLights.initialize(this.mode,this.settings),this.carManager.initialize(this.settings),this.sensorSystem.initialize(this.settings.DETECTOR_DISTANCE),this.statistics.initialize(),console.log("Game engine initialized")}setupEventListeners(){this.carManager.onCarCompleted=t=>{this.statistics.recordCarCompletion(t)}}update(t){if(this.trafficLights.update(t,this.mode,this.settings),this.carManager.update(t,this.trafficLights.getLightStates()),this.mode===i.MODES.ADAPTIVE){const e=this.sensorSystem.update(this.carManager.getCars());this.trafficLights.updateAdaptiveLogic(e,t)}this.statistics.update(this.carManager.getCars(),t)}render(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.intersection.render(this.ctx),this.mode===i.MODES.ADAPTIVE&&this.sensorSystem.render(this.ctx),this.carManager.render(this.ctx),this.trafficLights.render(this.ctx,this.intersection)}reset(){this.carManager.reset(),this.trafficLights.reset(),this.statistics.reset(),console.log("Game reset")}updateMode(t){this.mode=t,this.trafficLights.setMode(t),console.log(`Mode changed to: ${t}`)}updateSetting(t,e){switch(this.settings[t]=e,t){case"CAR_SPAWN_RATE":case"CAR_SPEED":case"TURN_RATE":this.carManager.updateSettings(this.settings);break;case"DETECTOR_DISTANCE":this.sensorSystem.updateDetectorDistance(e);break;case"GREEN_DURATION":case"YELLOW_DURATION":case"ALL_RED_DURATION":case"MIN_GREEN_TIME":this.trafficLights.updateSettings(this.settings);break}}updateSettings(t){this.settings={...this.settings,...t},this.trafficLights.updateSettings(this.settings),this.carManager.updateSettings(this.settings)}getStatistics(){return this.statistics.getStats()}getLightStates(){return this.trafficLights.getLightStates()}getCurrentMode(){return this.mode}getSettings(){return{...this.settings}}}class A{constructor(t){this.gameEngine=t,this.elements={},this.isPlaying=!0,this.initializeElements()}initializeElements(){this.elements={modeSelect:document.getElementById("mode-select"),playPauseBtn:document.getElementById("playPauseBtn"),resetBtn:document.getElementById("resetBtn"),fixedControls:document.getElementById("fixed-controls"),greenDuration:document.getElementById("greenDuration"),yellowDuration:document.getElementById("yellowDuration"),allRedDuration:document.getElementById("allRedDuration"),greenValue:document.getElementById("greenDurationValue"),yellowValue:document.getElementById("yellowDurationValue"),allRedValue:document.getElementById("redDurationValue"),adaptiveControls:document.getElementById("adaptive-controls"),detectorDistance:document.getElementById("detectorDistance"),minGreenTime:document.getElementById("minGreenTime"),detectorValue:document.getElementById("detectorValue"),minGreenValue:document.getElementById("minGreenValue"),carSpawnRate:document.getElementById("carSpawnRate"),carSpeed:document.getElementById("carSpeed"),turnRate:document.getElementById("turnRate"),spawnValue:document.getElementById("spawnValue"),speedValue:document.getElementById("speedValue"),turnValue:document.getElementById("turnValue"),carsPassedStat:document.getElementById("carsPassedStat"),avgWaitStat:document.getElementById("avgWaitStat"),currentCarsStat:document.getElementById("currentCarsStat"),northLight:document.getElementById("north-light"),eastLight:document.getElementById("east-light"),southLight:document.getElementById("south-light"),westLight:document.getElementById("west-light")}}initialize(){this.setupEventListeners(),this.updateModeDisplay(),this.startStatsUpdate()}setupEventListeners(){this.elements.modeSelect.addEventListener("change",t=>{this.gameEngine.updateMode(t.target.value),this.updateModeDisplay()}),this.elements.playPauseBtn.addEventListener("click",()=>{this.isPlaying=window.trafficSimulator.togglePause(),this.elements.playPauseBtn.textContent=this.isPlaying?"⏸️ Pause":"▶️ Play"}),this.elements.resetBtn.addEventListener("click",()=>{this.gameEngine.reset()}),this.setupSlider("greenDuration","greenValue","GREEN_DURATION",t=>t*1e3),this.setupSlider("yellowDuration","yellowValue","YELLOW_DURATION",t=>t*1e3),this.setupSlider("allRedDuration","allRedValue","ALL_RED_DURATION",t=>t*1e3),this.setupSlider("detectorDistance","detectorValue","DETECTOR_DISTANCE"),this.setupSlider("minGreenTime","minGreenValue","MIN_GREEN_TIME",t=>t*1e3),this.setupSlider("carSpawnRate","spawnValue","CAR_SPAWN_RATE"),this.setupSlider("carSpeed","speedValue","CAR_SPEED"),this.setupSlider("turnRate","turnValue","TURN_RATE",t=>t/100)}setupSlider(t,e,s,n=null){const r=this.elements[t],h=this.elements[e];!r||!h||(r.addEventListener("input",o=>{const c=parseFloat(o.target.value);h.textContent=c;const l=n?n(c):c;this.gameEngine.updateSetting(s,l)}),h.textContent=r.value)}updateModeDisplay(){this.gameEngine.getCurrentMode()===i.MODES.FIXED?(this.elements.fixedControls.style.display="block",this.elements.adaptiveControls.style.display="none"):(this.elements.fixedControls.style.display="none",this.elements.adaptiveControls.style.display="block")}startStatsUpdate(){setInterval(()=>{this.updateStatistics(),this.updateLightStatus()},100)}updateStatistics(){const t=this.gameEngine.getStatistics();this.elements.carsPassedStat.textContent=t.totalCarsPassed,this.elements.avgWaitStat.textContent=t.averageWaitTime.toFixed(1)+"s",this.elements.currentCarsStat.textContent=t.currentCars}updateLightStatus(){const t=this.gameEngine.getLightStates(),e={[i.DIRECTIONS.NORTH]:this.elements.northLight,[i.DIRECTIONS.EAST]:this.elements.eastLight,[i.DIRECTIONS.SOUTH]:this.elements.southLight,[i.DIRECTIONS.WEST]:this.elements.westLight};Object.entries(t).forEach(([s,n])=>{const r=e[s];r&&(r.classList.remove("red","yellow","green"),r.classList.add(n))})}setMode(t){this.elements.modeSelect.value=t,this.updateModeDisplay()}updateSliderValue(t,e){const s=this.elements[t];s&&(s.value=e,s.dispatchEvent(new Event("input")))}}document.getElementById("greenDuration").min=15;document.getElementById("greenDuration").max=100;document.getElementById("redDuration").min=15;document.getElementById("redDuration").max=100;const g=document.getElementById("greenDuration"),L=document.getElementById("greenDurationValue");g.addEventListener("input",()=>{L.textContent=g.value});const S=document.getElementById("yellowDuration"),P=document.getElementById("yellowDurationValue");S.addEventListener("input",()=>{P.textContent=S.value});const I=document.getElementById("redDuration"),_=document.getElementById("redDurationValue");I.addEventListener("input",()=>{_.textContent=I.value});class f{constructor(){this.canvas=document.getElementById("gameCanvas"),this.ctx=this.canvas.getContext("2d"),this.gameEngine=new O(this.canvas,this.ctx),this.uiController=new A(this.gameEngine),this.trafficLightController=new D,this.isRunning=!0,this.lastTime=0,this.initializeGame(),this.startGameLoop()}initializeGame(){this.canvas.width=i.CANVAS_WIDTH,this.canvas.height=i.CANVAS_HEIGHT,this.gameEngine.initialize(),this.uiController.initialize(),console.log("Traffic Simulator initialized")}startGameLoop(){const t=e=>{const s=e-this.lastTime;if(this.lastTime=e,this.isRunning){const n={GREEN_DURATION:Number(document.getElementById("greenDuration").value)*1e3,YELLOW_DURATION:Number(document.getElementById("yellowDuration").value)*1e3,ALL_RED_DURATION:Number(document.getElementById("redDuration").value)*1e3,CAR_SPAWN_RATE:Number(document.getElementById("carSpawnRate").value),CAR_SPEED:Number(document.getElementById("carSpeed").value),MIN_GREEN_TIME:5e3,DETECTOR_DISTANCE:200};this.gameEngine.updateSettings(n),this.gameEngine.update(s)}this.gameEngine.render(),requestAnimationFrame(t)};requestAnimationFrame(t)}pause(){this.isRunning=!1}resume(){this.isRunning=!0}reset(){this.gameEngine.reset()}togglePause(){return this.isRunning=!this.isRunning,this.isRunning}}document.addEventListener("DOMContentLoaded",()=>{window.trafficSimulator=new f});new f;
